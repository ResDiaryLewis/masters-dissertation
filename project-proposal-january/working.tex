\documentclass[11pt]{article}

\usepackage[margin=25mm,a4paper]{geometry}

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\title{Distributed Tracing}

\author{Nicola M\"{o}ssner \\ 2268685m}

\date{17. January 2020}

\usepackage[numbers]{natbib}

\begin{document}

\maketitle

\section{Background}

% A background, including a general description of the context of the problem and relevance to the industry partner.

When reflecting on the Software Development Life Cycle (SDLC) of different projects I have personally been involved in, observed, or read about, it becomes apparent to me that the last stage which is often described as the 'Maintenance stage' forms a major part of the whole software development process.


Maintenance involves various disciplines, such as: % TODO: Maybe reference https://www.econnectivity.se/app-maintenance-cost-can-be-three-times-higher-than-development-cost/
\begin{itemize}
    \item Correcting issues/bugs in the code.
    \item Adapting the behaviour of the application to meet changing and evolving requirements.
    \item Enhancing the performance of the software to improve user experience and satisfaction.
    \item Updating technologies, platforms, frameworks and infrastructure to keep up with the latest standards and innovations, and making necessary changes to the software accordingly.
    \item Monitoring and analysing the behaviour and performance of the software.
\end{itemize}
It is in fact widely known and agreed on that the maintenance cost far exceeds the development costs for most software projects. Maintaining and improving an existing software application/solutin consumes a vast amount of resources and this is no different at my current employer, ResDiary. % TODO: Give evidence of this, maybe a study or percentage

ResDiary provides its customers with a reservation and table management system for the hospitality sector. The nature of this industry demands highly available and well performing software solutions. Lacking in those areas can result in loss of profit for our customers. For this reason we are constantly monitoring and enhancing the stability and performance of the services we provide.

To improve the process of pinpointing potential areas of improvement, we are eager to introduce \textit{Distributed Tracing} to our appliactions.
\begin{quote}
    Distributed tracing helps pinpoint where failures occur and what causes poor performance. \cite{opentracing.io/docs}
\end{quote}  
With this in mind, we expect this method to assist us in identifying issues in our software that we can address either with an immediate quick fix, or a with a complete overhaul of a particular software component, sql query, etc.

\section{Problem Description}

% An explanation of the nature of the problem to be addressed, the symptoms, the extent of the problem (is it specific to
% your employer, a sector, or the wider software industry?), and associated evidence in support of your description of the
% problem (conversations with team members, literature, personal diary entries).

Occasioanl long request times, 

With the growing trend of microservices, orchestrated into large-scale applications, it becomes more challenging to trace errors in the code, to spot bottle-necks and slow parts of the application, to find buggy code or to simply find areas of improvement. For example, when a request to a web application takes longer than expected, it is difficult to determine if this was caused by part of the application code, a database query, perhaps some code in another web-app that the request gets routed to or a call to a third party application/library.

At ResDiary we currently have no distinct approach to investigate the cause for slow or failing requests. At the moment we resort to log messages and graphs depicting the health and/or uptime of components and infrastructure. This approach can be very broad and slow as it takes time to pin down the exact nature of an issue and may involve some guesses and investigation into a wrong direction at first. 





Tracing an incoming request from start to finish, and timing how much time it takes within the different components and perhaps even functions and methods of the whole application would shed some light onto those existing issues and provide a clear and straight forward way of determining areas of improvment.

Another aspect where we would hope to see benefits from such a tool, is an improved ...(response/reaction/fixing) time for our on-call developers who deal with alerts relating to our web-applications and databases. Allwoing them to use a 'Distributed Tracing System' to track for example slow or failing requests from users would give them an insight into where the problem occurs and allow them to fix it faster.

- How do we trace errors at the moment (Grafana, Stackify, Kibana)?

- Experiences at ResDiary: Query tuning (try to improve response time of a request, only after the enhancements were made, deployed and observed over time in production, we can say for sure if the improvements to the query had an impact. This is a slow process, through tracing we could say for sure beforehand if the query was the issue, the thing that took too long.)

\section{Objectives} 

% Give the set of objectives describing the outcomes of the project, either in terms of knowledge acquired through
% experimentation or artefacts delivered (including software code, data sets, process documentation, for example).  These
% objectives will specify the *Definition of Done* for the overall project.

The choice of an appropriate \textit{Tracing Framework} is part of the Work Plan (see section \ref{WorkPlan}), hence for now I will refer to it as \textit{Tracing Framework}. Possible choices are \textit{OpenTracing} and \textit{.NET Core 3.0 Diagnostics}.

In the same manner, I will refer to the eventual implementation choice of the \textit{Distributed Tracing System} such as \textit{Jaeger} or \textit{ZipKin} simply as \textit{Distributed Tracing System}.

\textbf{1.} The \textit{Tracing Framework} is implemented in our \textit{.NET Core} applications.

    % How do we do this?
    % Add some code to our existing apps or have an extra app for this?
    % Only to the ones running in Kubernetes?
    % Use OpenTracing or .NET Core 3.0 Diagnostics?

\textbf{2.} Delivered a \textit{helm} chart for the \textit{Distributed Tracing System} that can be deployed locally and to Azure Kubernetes Services (AKS).

\textbf{3.} The \textit{Distributed Tracing System} is running in the ResDiary AKS staging cluster.

\textbf{4.} The \textit{Distributed Tracing System} is running in the ResDiary AKS production cluster.

\textbf{5.} Traces gathered through the \textit{Tracing Framework} are visualised meaningfully in the \textit{Distributed Tracing System}.

\textbf{6.} Delivered an experience report from the DevOps team and on-call developers at ResDiary, discussing some of the following concerns:
\begin{itemize}
    \item How has this new approach affected the process of finding issues in general?
    \item How has it affected the time to get to the bottom of (and resolve) an on-call support incidents?
    \item Does this additional tool increase your confidence to track and resolve issues while on-call or in your everyday work?
    \item Does the data gathered and depicted in the \textit{Distributed Tracing System} provide useful indications for areas of improvement.
\end{itemize}

\section{Work Plan}
\label{WorkPlan}

% Describe the overall approach and the different work packages of work that will need to be undertaken in order to
% achieve the stated objectives.  Each work package should have a title, short description, an assigned outcome
% (Definition of Done), a due date and a list of assignees (student, employer etc) including the lead responsible for
% ensuring the work is completed.  An example of a work package might be "Deploy Release 1.0 (Prototype 1) to Employer
% Infrastructure".

% \begin{tabular}{ | p{3cm} | p{5cm}| p{3cm} | p{2cm} | p{2cm} | } 
% \hline
% \textbf{Title} & \textbf{Description} & \textbf{Outcome} & \textbf{Due date} & \textbf{Assignees} \\ 
% \hline
% Decide on \textit{Tracing Framework} & Investigate differences, pros and cons between frameworks (OpenTracing, etc.) and choose the most appropriate one. & Brief statement justifying the decision. & 16.10.2020 & Nicola M\"{o}ssner* \\ 
% \hline
% Decide on \textit{Distributed Tracing System} & Investigate differences, pros and cons between systems (Zipkin, LighStep, Jaeger, etc.) and choose the most appropriate one. & Brief statement justifying the decision. & 16.10.2020 & Nicola M\"{o}ssner* \\ 
% \hline
% Instrument applications with Tracing Framework & ... & All resources are created as expected and Pods are running & 30.10.2020 & Nicola M\"{o}ssner* \\ 
% \hline
% Deploy Distributed Tracing System locally & Produce, configure and deploy a helm chart for the Distributed Tracing System on a local Kubernetes cluster. & All resources are created as expected and Pods are running & 30.10.2020 & Nicola M\"{o}ssner* \\ 
% \hline
% \end{tabular}

\textbf{Decide on \textit{Tracing Framework} (16.10.2020)}\\
Investigate the differences, pros and cons between frameworks (OpenTracing, etc.) and choose the most appropriate one.\\
Outcome: Brief statement justifying the decision.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Decide on \textit{Distributed Tracing System} (16.10.2020)}\\
Investigate the differences, pros and cons between systems (Zipkin, LighStep, Jaeger, etc.) and choose the most appropriate one.\\
Outcome: Brief statement justifying the decision.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Instrument applications with Tracing Framework (30.10.2020)}\\
The existing .NET Core applications need to be instrumented with the tracing framework for it to be able to trace requests. \\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Deploy Distributed Tracing System locally (06.11.2020)}\\
Configure and deploy a helm chart for the Distributed Tracing System on a local Kubernetes cluster.\\
Outcome: All resources are created as expected and Pods are running in local Kubernetes cluster.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Tracing Framework communicating with Distributed Tracing System locally (27.11.2020)}\\
...\\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Deploy Distributed Tracing System to staging environment (01.01.2021)}\\
Configure and deploy a helm chart for the Distributed Tracing System on a local Kubernetes cluster.\\
Outcome: All resources are created as expected and Pods are running in ResDiary AKS staging cluster.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Tracing Framework communicating with Distributed Tracing System in staging environment (15.01.2021)}\\
...\\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Mid-point demonstration (09.04.2021)}\\
Give a demonstration of the current state of the project to the employer.\\
Outcome: Current state demonstrated and feedback collected.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Deploy Distributed Tracing System to production environment (28.01.2021)}\\
Configure and deploy a helm chart for the Distributed Tracing System on a local Kubernetes cluster.\\
Outcome: All resources are created as expected and Pods are running in ResDiary AKS production cluster.\\
Assignees: Nicola M\"{o}ssner*

\textbf{Tracing Framework communicating with Distributed Tracing System in production environment (12.02.2021)}\\
...\\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Visualise meaningful traces in Distributed Tracing System (26.02.2021)}\\
...\\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Finish experience report of developers using the tool (26.03.2021)}\\
...\\
Outcome: \\
Assignees: Nicola M\"{o}ssner*

\textbf{Finish demonstration and handover (09.04.2021)}\\
Give a demonstration of the final state of the project to the employer and handover all artefacts.\\
Outcome: Final state demonstrated, artefacts handed over and feedback collected.\\
Assignees: Nicola M\"{o}ssner*

* Signifies the lead responsible for ensuring the work is completed.

\bibliographystyle{plainnat}

\bibliography{bibliography}

\end{document}
